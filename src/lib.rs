#![forbid(unsafe_code)]

use std::{
    collections::{BTreeMap, HashSet},
    fs, io,
    path::{Path, PathBuf},
    time::{SystemTime, UNIX_EPOCH},
};

use anyhow::{Context, Result, anyhow, bail};

#[derive(Debug, Clone, serde::Deserialize)]
pub struct Config {
    pub configs: BTreeMap<String, String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Mapping {
    pub source: PathBuf,
    pub target: PathBuf,
}

#[derive(Debug, Clone)]
pub struct MapperOptions {
    pub working_dir: PathBuf,
    pub config_path: PathBuf,
    pub dry_run: bool,
    pub backup_dir: Option<PathBuf>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct OperationOutcome {
    pub source: PathBuf,
    pub target: PathBuf,
    pub backup: Option<PathBuf>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ExecutionSummary {
    pub dry_run: bool,
    pub backup_dir: Option<PathBuf>,
    pub operations: Vec<OperationOutcome>,
}

pub fn run(options: &MapperOptions) -> Result<ExecutionSummary> {
    let config_path = resolve_config_path(&options.working_dir, &options.config_path);
    if !config_path.exists() {
        bail!("config file not found: {}", config_path.as_path().display());
    }

    let config = load_config(&config_path)?;
    let mappings = plan_mappings(&config, &options.working_dir)?;
    execute_mappings(&mappings, options)
}

pub fn load_config(path: &Path) -> Result<Config> {
    let config_str = fs::read_to_string(path)
        .with_context(|| format!("failed to read config file {}", path.display()))?;

    toml::from_str::<Config>(&config_str)
        .with_context(|| format!("failed to parse TOML config {}", path.display()))
}

pub fn plan_mappings(config: &Config, working_dir: &Path) -> Result<Vec<Mapping>> {
    if config.configs.is_empty() {
        bail!("[configs] is empty");
    }

    let mut mappings = Vec::new();
    let mut seen_targets = HashSet::new();

    for (source_pattern, target_root) in &config.configs {
        let target_root = resolve_target_root(target_root, working_dir)
            .with_context(|| format!("invalid target path {target_root:?}"))?;

        let expanded_pattern = expand_shell_value(source_pattern)
            .with_context(|| format!("invalid source glob pattern {source_pattern:?}"))?;

        let absolute_pattern = if Path::new(&expanded_pattern).is_absolute() {
            expanded_pattern
        } else {
            working_dir
                .join(expanded_pattern)
                .to_string_lossy()
                .into_owned()
        };

        let mut matches = 0usize;
        for entry in glob::glob(&absolute_pattern)
            .with_context(|| format!("invalid glob syntax: {source_pattern}"))?
        {
            let source = entry.with_context(|| {
                format!(
                    "failed to iterate glob entry for pattern {}",
                    source_pattern
                )
            })?;

            let file_name = source.file_name().ok_or_else(|| {
                anyhow!(
                    "glob entry has no file name: {}",
                    source.as_path().display()
                )
            })?;

            let target = target_root.join(file_name);
            if !seen_targets.insert(target.clone()) {
                bail!(
                    "duplicate target path generated by config: {}",
                    target.as_path().display()
                );
            }

            mappings.push(Mapping { source, target });
            matches += 1;
        }

        if matches == 0 {
            bail!("glob pattern matched no files: {source_pattern}");
        }
    }

    mappings.sort_by(|left, right| left.target.cmp(&right.target));
    Ok(mappings)
}

pub fn execute_mappings(mappings: &[Mapping], options: &MapperOptions) -> Result<ExecutionSummary> {
    let backup_dir = options
        .backup_dir
        .clone()
        .unwrap_or_else(|| options.working_dir.join(format!("backup-{}", now_millis())));

    let mut operations = Vec::with_capacity(mappings.len());
    let mut used_backup = false;

    for (index, mapping) in mappings.iter().enumerate() {
        ensure_parent_exists(mapping.target.as_path(), options.dry_run)?;

        let mut backup = None;
        if path_exists(mapping.target.as_path())? {
            let backup_path = backup_dir.join(backup_name(index, mapping.target.as_path()));
            backup_existing(
                mapping.target.as_path(),
                backup_path.as_path(),
                options.dry_run,
            )?;
            backup = Some(backup_path);
            used_backup = true;
        }

        if !options.dry_run {
            create_symlink(mapping.source.as_path(), mapping.target.as_path()).with_context(
                || {
                    format!(
                        "failed to create symlink {} -> {}",
                        mapping.source.as_path().display(),
                        mapping.target.as_path().display()
                    )
                },
            )?;
        }

        operations.push(OperationOutcome {
            source: mapping.source.clone(),
            target: mapping.target.clone(),
            backup,
        });
    }

    Ok(ExecutionSummary {
        dry_run: options.dry_run,
        backup_dir: used_backup.then_some(backup_dir),
        operations,
    })
}

fn resolve_config_path(working_dir: &Path, config_path: &Path) -> PathBuf {
    if config_path.is_absolute() {
        config_path.to_path_buf()
    } else {
        working_dir.join(config_path)
    }
}

fn resolve_target_root(target: &str, working_dir: &Path) -> Result<PathBuf> {
    let expanded = expand_shell_value(target)?;
    let target_path = PathBuf::from(expanded);

    if target_path.is_absolute() {
        Ok(target_path)
    } else {
        Ok(working_dir.join(target_path))
    }
}

fn expand_shell_value(value: &str) -> Result<String> {
    shellexpand::full(value)
        .map(|expanded| expanded.into_owned())
        .map_err(|err| anyhow!(err.to_string()))
}

fn ensure_parent_exists(path: &Path, dry_run: bool) -> Result<()> {
    let parent = path.parent().ok_or_else(|| {
        anyhow!(
            "target path has no parent directory: {}",
            path.as_os_str().to_string_lossy()
        )
    })?;

    if dry_run {
        return Ok(());
    }

    fs::create_dir_all(parent)
        .with_context(|| format!("failed to create target directory {}", parent.display()))
}

fn path_exists(path: &Path) -> Result<bool> {
    match fs::symlink_metadata(path) {
        Ok(_) => Ok(true),
        Err(err) if err.kind() == io::ErrorKind::NotFound => Ok(false),
        Err(err) => {
            Err(err).with_context(|| format!("failed to inspect existing path {}", path.display()))
        }
    }
}

fn backup_existing(target: &Path, backup_path: &Path, dry_run: bool) -> Result<()> {
    if dry_run {
        return Ok(());
    }

    if let Some(parent) = backup_path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("failed to create backup directory {}", parent.display()))?;
    }

    match fs::rename(target, backup_path) {
        Ok(()) => Ok(()),
        Err(err) if err.kind() == io::ErrorKind::CrossesDevices => {
            copy_then_remove(target, backup_path)
        }
        Err(err) => Err(err).with_context(|| {
            format!(
                "failed to back up existing target {}",
                target.as_os_str().to_string_lossy()
            )
        }),
    }
}

fn copy_then_remove(source: &Path, destination: &Path) -> Result<()> {
    let metadata = fs::symlink_metadata(source)
        .with_context(|| format!("failed to inspect existing path {}", source.display()))?;

    if metadata.file_type().is_symlink() {
        let link_target = fs::read_link(source)
            .with_context(|| format!("failed to read symlink {}", source.display()))?;
        create_symlink(link_target.as_path(), destination)
            .with_context(|| format!("failed to copy symlink {}", source.display()))?;
        remove_existing(source)?;
        return Ok(());
    }

    if metadata.is_dir() {
        fs::create_dir_all(destination)
            .with_context(|| format!("failed to create backup dir {}", destination.display()))?;
        let mut options = fs_extra::dir::CopyOptions::new();
        options.content_only = true;
        options.overwrite = true;

        fs_extra::dir::copy(source, destination, &options)
            .map_err(|err| anyhow!("failed to copy directory {}: {err}", source.display()))?;
    } else {
        fs::copy(source, destination)
            .with_context(|| format!("failed to copy file {}", source.display()))?;
    }

    remove_existing(source)
}

fn remove_existing(path: &Path) -> Result<()> {
    let metadata = fs::symlink_metadata(path)
        .with_context(|| format!("failed to inspect existing target {}", path.display()))?;

    if metadata.file_type().is_dir() && !metadata.file_type().is_symlink() {
        fs::remove_dir_all(path)
            .with_context(|| format!("failed to remove directory {}", path.display()))
    } else {
        remove_file_or_symlink(path)
    }
}

fn remove_file_or_symlink(path: &Path) -> Result<()> {
    match fs::remove_file(path) {
        Ok(()) => Ok(()),
        Err(err) if err.kind() == io::ErrorKind::IsADirectory => fs::remove_dir(path)
            .with_context(|| format!("failed to remove symlink directory {}", path.display())),
        Err(err) => Err(err).with_context(|| format!("failed to remove file {}", path.display())),
    }
}

fn backup_name(index: usize, target: &Path) -> String {
    let base = target
        .file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("target");

    let sanitized = base
        .chars()
        .map(|ch| match ch {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '.' | '_' | '-' => ch,
            _ => '_',
        })
        .collect::<String>();

    format!("{:04}_{sanitized}", index + 1)
}

fn now_millis() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("system time before unix epoch")
        .as_millis()
}

#[cfg(unix)]
fn create_symlink(source: &Path, target: &Path) -> io::Result<()> {
    std::os::unix::fs::symlink(source, target)
}

#[cfg(windows)]
fn create_symlink(source: &Path, target: &Path) -> io::Result<()> {
    let source_meta = fs::metadata(source)?;
    if source_meta.is_dir() {
        std::os::windows::fs::symlink_dir(source, target)
    } else {
        std::os::windows::fs::symlink_file(source, target)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn plan_mappings_builds_target_paths() {
        let root = tempdir().expect("tempdir");
        let working_dir = root.path();
        fs::create_dir_all(working_dir.join("src")).expect("create src dir");
        fs::write(working_dir.join("src/app.toml"), "x=1").expect("write app");
        fs::write(working_dir.join("src/gui.toml"), "y=1").expect("write gui");

        let config = Config {
            configs: BTreeMap::from([(String::from("src/*.toml"), String::from("dest"))]),
        };

        let mappings = plan_mappings(&config, working_dir).expect("plan mappings");
        assert_eq!(mappings.len(), 2);
        assert!(
            mappings
                .iter()
                .any(|m| m.target == working_dir.join("dest/app.toml"))
        );
        assert!(
            mappings
                .iter()
                .any(|m| m.target == working_dir.join("dest/gui.toml"))
        );
    }

    #[test]
    fn plan_mappings_rejects_empty_glob() {
        let root = tempdir().expect("tempdir");
        let config = Config {
            configs: BTreeMap::from([(String::from("missing/*.toml"), String::from("dest"))]),
        };

        let err = plan_mappings(&config, root.path()).expect_err("expected no matches error");
        assert!(err.to_string().contains("matched no files"));
    }

    #[test]
    fn plan_mappings_rejects_duplicate_targets() {
        let root = tempdir().expect("tempdir");
        let working_dir = root.path();
        fs::create_dir_all(working_dir.join("a")).expect("create dir a");
        fs::create_dir_all(working_dir.join("b")).expect("create dir b");
        fs::write(working_dir.join("a/shared.conf"), "a").expect("write a file");
        fs::write(working_dir.join("b/shared.conf"), "b").expect("write b file");

        let config = Config {
            configs: BTreeMap::from([
                (String::from("a/*.conf"), String::from("dest")),
                (String::from("b/*.conf"), String::from("dest")),
            ]),
        };

        let err = plan_mappings(&config, working_dir).expect_err("expected duplicate target error");
        assert!(err.to_string().contains("duplicate target"));
    }

    #[test]
    fn dry_run_does_not_change_existing_file() {
        let root = tempdir().expect("tempdir");
        let working_dir = root.path();
        let source = working_dir.join("src.conf");
        let target = working_dir.join("target.conf");

        fs::write(&source, "new").expect("write source");
        fs::write(&target, "old").expect("write target");

        let options = MapperOptions {
            working_dir: working_dir.to_path_buf(),
            config_path: PathBuf::from("configs.toml"),
            dry_run: true,
            backup_dir: Some(working_dir.join("backups")),
        };

        let mappings = vec![Mapping {
            source: source.clone(),
            target: target.clone(),
        }];

        let summary = execute_mappings(&mappings, &options).expect("dry run execution");
        assert_eq!(summary.operations.len(), 1);
        assert_eq!(
            fs::read_to_string(target).expect("read target after dry run"),
            "old"
        );
        assert!(!working_dir.join("backups").exists());
    }

    #[cfg(unix)]
    #[test]
    fn execute_mappings_replaces_broken_symlink_target() {
        let root = tempdir().expect("tempdir");
        let working_dir = root.path();
        let source = working_dir.join("source.conf");
        let target = working_dir.join("target.conf");

        fs::write(&source, "new").expect("write source");
        std::os::unix::fs::symlink(working_dir.join("missing.conf"), &target)
            .expect("create broken symlink target");

        let options = MapperOptions {
            working_dir: working_dir.to_path_buf(),
            config_path: PathBuf::from("configs.toml"),
            dry_run: false,
            backup_dir: Some(working_dir.join("backups")),
        };

        let mappings = vec![Mapping {
            source: source.clone(),
            target: target.clone(),
        }];

        execute_mappings(&mappings, &options).expect("execute mappings");

        let link_target = fs::read_link(&target).expect("read target symlink");
        assert_eq!(link_target, source);

        let backup_entries = fs::read_dir(working_dir.join("backups"))
            .expect("read backup dir")
            .collect::<Result<Vec<_>, _>>()
            .expect("collect backup entries");
        assert_eq!(backup_entries.len(), 1);
        let backup_meta = fs::symlink_metadata(backup_entries[0].path()).expect("backup metadata");
        assert!(backup_meta.file_type().is_symlink());
    }
}
